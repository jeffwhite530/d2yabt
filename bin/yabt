#!/usr/bin/env python3



# pylint: disable=line-too-long



import yabt
import sys
import os
import argparse
import gzip
import shutil
import json
import re
import signal
import glob
import zipfile
import tarfile



def trap_sigint(signal, frame):
	sys.exit(0)



def decompress_gzip_files(start_dir):
	"""Walk a directory tree and decompress all gzip files found.
	"""
	print("Expanding bundle files")

	for root, dirs, files in os.walk(start_dir):
		for each_file in files:
			if not each_file.endswith(".gz"):
				continue

			file_with_path = root + os.sep + each_file

			file_with_path_no_ext = file_with_path[:-3]

			try:
				with gzip.open(file_with_path, "rb") as f_in:
					with open(file_with_path_no_ext, "wb") as f_out:
						shutil.copyfileobj(f_in, f_out)

			except EOFError:
				print("Failed to expand", file_with_path, "EOF reached, incomplete file?")

			except OSError:
				print("Failed to expand", file_with_path + ", not a gzip file?")

			else:
				os.remove(file_with_path)



def format_json(bundle_dir):
	"""Format the JSON files into a human-readable form.
	"""
	print("Formatting JSON files")

	for root, dirs, files in os.walk(bundle_dir):
		for each_file in files:
			if not each_file.endswith(".json"):
				continue

			# This file always fails to parse, just skip it
			if each_file == "443-licensing_v1_audit_decrypt_1.json":
				continue

			file_with_path = root + os.sep + each_file

			with open(file_with_path, "r+") as json_file_handle:
				try:
					json_data = json.load(json_file_handle)

					json_file_handle.seek(0)

					json_file_handle.write(json.dumps(json_data, indent=2, sort_keys=True))
					json_file_handle.write("\n")

				except (json.decoder.JSONDecodeError, UnicodeDecodeError):
					print("Failed to parse JSON:", file_with_path, file=sys.stderr)



def get_bundle_type(bundle):
	"""Determine the type of bundle given and return a string of either:
		* dcos_diag
		* dcos_oneliner
	"""

	if os.path.isdir(bundle_name):
		if glob.glob(bundle_name + os.sep + "*_master/dcos-mesos-master.service"):
			return "dcos_diag"

		if glob.glob(bundle_name + os.sep + "dcos-mesos-master.service.log"):
			return "dcos_oneliner"

		if glob.glob(bundle_name + os.sep + "dcos-mesos-slave*.service.log"):
			return "dcos_oneliner"

	elif os.path.isfile(bundle_name):
		if bundle_name.endswith(".zip"):
			myzip = zipfile.ZipFile(bundle_name)

			for each in myzip.namelist():
				if each.endswith("_master/dcos-mesos-master.service.gz"):
					return "dcos_diag"

		if bundle_name.endswith(".tgz"):
			mytar = tarfile.open(bundle_name, "r:gz")

			for each in mytar.getmembers():
				if each.name.endswith("dcos-mesos-master.service.log"):
					return "dcos_oneliner"

				if each.name.endswith("dcos-mesos-slave.service.log"):
					return "dcos_oneliner"

				if each.name.endswith("dcos-mesos-slave-public.service.log"):
					return "dcos_oneliner"

	print("Unable to determine bundle type", file=sys.stderr)

	sys.exit(1)



def is_bundle_extracted(bundle_name):
	"""Checks if the named bundle is already extracted.
		If yes: return True
		If no: return False
	"""

	bundle_dir = bundle_name[:-4]

	if os.path.exists(bundle_dir):
		return True

	else:
		return False



if __name__ == "__main__":
	# What options were we called with?
	parser = argparse.ArgumentParser(description="Yet Another Bundle Tool: A tool used to analyze DC/OS diagnostic bundles")

	parser.add_argument("-d", "--debug", dest="debug_mode",
							default=False, action="store_true",
							help="Enable debug mode")

	parser.add_argument("bundle_name", metavar="bundle_name",
							type=str, nargs="+",
							help="The bundle file or directory")

	# TODO: Add option to only look at a specific node
	# TODO: Add option to skip checks and only extract unless given this or another option

	yabt_args = parser.parse_args()


	# Trap CTRL+C (SIGINT)
	signal.signal(signal.SIGINT, trap_sigint)


	# Verify we have a bundle arg
	if not len(yabt_args.bundle_name) == 1:
		print("Invalid number of bundle names passed, shell quoting problem?", file=sys.stderr)

		sys.exit(1)

	else:
		bundle_name = yabt_args.bundle_name[0]


	# TODO: Support service diagnostic bundles


	# Does the named bundle exist?
	if not os.path.exists(bundle_name):
		print("No such bundle found:", bundle_name, file=sys.stderr)

		sys.exit(1)


	# Decompress the bundle and the files within it
	bundle_type = get_bundle_type(bundle_name)

	if os.path.isdir(bundle_name):
		bundle_dir = bundle_name

	elif is_bundle_extracted(bundle_name):
		bundle_dir = bundle_name[:-4]

		print("Bundle has already been extracted, using existing directory", bundle_dir)

	elif bundle_type == "dcos_diag" and os.path.isfile(bundle_name):
		bundle_dir = yabt.dcos.extract_bundle(bundle_name)
		decompress_gzip_files(bundle_dir)
		format_json(bundle_dir)

	elif bundle_type == "dcos_oneliner" and os.path.isfile(bundle_name):
		bundle_dir = yabt.dcos.extract_oneliner(bundle_name)


	# Create the node objects list
	node_objs = yabt.dcos.get_nodes(bundle_dir, bundle_type)

	yabt.dcos.print_nodes(node_objs)


	# Health checks
	if bundle_type == "diag_bundle":
		yabt.check.dcos_version(node_objs)
		yabt.check.firewall_running(node_objs)
		yabt.check.state_size(node_objs)
		yabt.check.inactive_frameworks(node_objs)
		yabt.check.missing_dockerd(node_objs)
		yabt.check.unreachable_agents_mesos_state(node_objs)

	yabt.check.unreachable_agents_mesos_log(node_objs)
	yabt.check.mesos_leader_changes(node_objs)
	yabt.check.zk_leader_changes(node_objs)
	yabt.check.marathon_leader_changes(node_objs)
	yabt.check.check_time_failures(node_objs)
	yabt.check.kmem_presence(node_objs)
	yabt.check.zk_fsync(node_objs)
	yabt.check.zk_diskspace(node_objs)
	yabt.check.zk_connection_exception(node_objs)
	yabt.check.oom_presence(node_objs)
	yabt.check.crdb_underrep_ranges(node_objs)
	yabt.check.crdb_monotonicity_error(node_objs)
	yabt.check.crdb_contact_error(node_objs)

	# TODO: check_mesos_master()
	# TODO: Check for private registry certificate errors
	# TODO: Check for overlay master module in RECOVERING state events

